---
phase: 05-stress-test-wizards-arena-integration
plan: 03
type: execute
wave: 2
depends_on: ["05-01", "05-02"]
files_modified:
  - crates/omega-tui/src/arena.rs
  - crates/omega-tui/src/lib.rs
  - crates/omega-bevy/src/presentation/arena_controls.rs
  - crates/omega-bevy/src/presentation/mod.rs
autonomous: true

must_haves:
  truths:
    - "TUI arena scene renders catastrophe control buttons and elemental brush"
    - "Performance HUD shows traffic light indicator, live counters, and collapsible event log"
    - "Mouse painting injects Fire/Water/Ash into CA grid cells"
    - "Bevy arena gets catastrophe buttons and snapshot controls in egui panel"
  artifacts:
    - path: "crates/omega-tui/src/arena.rs"
      provides: "TUI arena scene with perf HUD, catastrophe controls, elemental brush, monster spawner"
      exports: ["ArenaUi", "BrushMode"]
    - path: "crates/omega-bevy/src/presentation/arena_controls.rs"
      provides: "Bevy egui panel for catastrophe triggers, snapshot, turret toggle"
      exports: ["arena_controls_ui_system"]
  key_links:
    - from: "crates/omega-tui/src/arena.rs"
      to: "crates/omega-core/src/simulation/catastrophe.rs"
      via: "Catastrophe scenario invocation"
      pattern: "Catastrophe::"
    - from: "crates/omega-tui/src/arena.rs"
      to: "crates/omega-core/src/simulation/snapshot.rs"
      via: "Snapshot capture/restore"
      pattern: "SnapshotManager"
    - from: "crates/omega-bevy/src/presentation/arena_controls.rs"
      to: "crates/omega-bevy/src/simulation/turret.rs"
      via: "TurretMode toggle"
      pattern: "TurretMode"
---

<objective>
Build the user-facing arena controls for both TUI and Bevy frontends: catastrophe triggers, elemental brush, performance HUD, monster spawner, and snapshot controls.

Purpose: Satisfy TEST-01 (Wizard's Arena test scene for sandbox interaction) with full God Mode controls in both frontends.
Output: TUI arena module with rendering and input handling. Bevy arena controls panel with egui.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-stress-test-wizards-arena-integration/05-01-SUMMARY.md
@.planning/phases/05-stress-test-wizards-arena-integration/05-02-SUMMARY.md
@crates/omega-tui/src/lib.rs
@crates/omega-bevy/src/presentation/spawner.rs
@crates/omega-core/src/simulation/catastrophe.rs
@crates/omega-core/src/simulation/snapshot.rs
@crates/omega-bevy/src/simulation/diagnostics.rs
@crates/omega-bevy/src/simulation/turret.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement TUI arena controls module</name>
  <files>
    crates/omega-tui/src/arena.rs
    crates/omega-tui/src/lib.rs
  </files>
  <action>
Create `arena.rs` with a self-contained TUI arena controls module. This is NOT a replacement for the existing game loop in lib.rs - it provides widgets and input handling that the existing TUI arena path can call.

1. **BrushMode** enum: `Fire`, `Water`, `Ash`, `None`.

2. **ArenaUi** struct:
   ```rust
   pub struct ArenaUi {
       pub brush_mode: BrushMode,
       pub show_perf_hud: bool,
       pub show_logs: bool,
       pub spawner_selected: usize,
       pub spawner_catalog: Vec<String>,  // ["rat", "goblin", "ogre"]
       pub snapshot_manager: SnapshotManager,
       pub event_log: Vec<String>,        // Last 20 events
       pub fps: f64,
       pub ca_update_ms: f64,
       pub projectile_count: usize,
       pub particle_count: usize,
       pub turret_active: bool,
   }
   ```

3. **render_controls_panel** method - Renders right-side control panel using Ratatui:
   - Layout: Vertical split into 4 sections:
     a. **Catastrophe Controls** (Length 8): Labeled buttons as key hints:
        - `[1] Great Flood  [2] Forest Fire  [3] Windstorm`
        - `[4] Fuel Field   [5] Doomsday`
        - `[S] Snapshot  [R] Restore  [T] Turret: ON/OFF`
     b. **Elemental Brush** (Length 4):
        - `Brush: [F]ire [W]ater [A]sh [N]one`
        - Current selection highlighted with color.
     c. **Monster Spawner** (Length 6):
        - Ratatui List widget showing catalog entries.
        - `[Up/Down] Select  [Enter] Spawn at cursor`
     d. **Performance HUD** (Min remaining):
        - Traffic light: colored dot + FPS + label (Green >=58, Yellow >=45, Red <45).
        - Counters line: `Proj: {n}  Part: {n}  CA: {ms}ms`
        - If `show_logs`: scrollable event log below.
        - Toggle: `[L] Logs`

4. **handle_arena_input** method - Processes keyboard/mouse input:
   - `KeyCode::Char('1')` -> `Catastrophe::great_flood(grid, center)`
   - `KeyCode::Char('2')` -> `Catastrophe::forest_fire_jump(grid, origin)`
   - `KeyCode::Char('3')` -> `Catastrophe::massive_windstorm(wind_grid)`
   - `KeyCode::Char('4')` -> `Catastrophe::fuel_field(grid)`
   - `KeyCode::Char('5')` -> `Catastrophe::doomsday(grid, wind_grid)`
   - `KeyCode::Char('s')` -> `snapshot_manager.push(ArenaSnapshot::capture(grid, label))`
   - `KeyCode::Char('r')` -> `snapshot_manager.pop().map(|s| s.restore(grid))`
   - `KeyCode::Char('t')` -> toggle `turret_active`
   - `KeyCode::Char('f')` -> `brush_mode = BrushMode::Fire`
   - `KeyCode::Char('w')` -> `brush_mode = BrushMode::Water`
   - `KeyCode::Char('a')` -> `brush_mode = BrushMode::Ash`
   - `KeyCode::Char('n')` -> `brush_mode = BrushMode::None`
   - `KeyCode::Char('l')` -> toggle `show_logs`
   - Mouse click/drag in map area with brush active -> inject element at grid position.
   - Returns an enum indicating what action was taken (for the caller to dispatch).

5. **handle_brush_paint** method:
   - Takes `MouseEvent`, `map_area: Rect`, `grid: &mut CaGrid`.
   - On `MouseEventKind::Down` or `MouseEventKind::Drag`:
     - Convert terminal (column, row) to grid (x, y) by subtracting map_area offset.
     - Apply brush: Fire sets heat=150, Water sets wet=80 + liquid=Water, Ash sets solid=Ash.
   - Rate-limit: skip if last paint was <100ms ago (store last_paint_time in ArenaUi).

6. **update_perf_data** method:
   - Called by the game loop to push fresh metrics. Accepts fps, ca_update_ms, projectile_count, particle_count, event_log entries.

Update `lib.rs`:
- Add `pub mod arena;` at the top.
- In the existing wizard arena game loop path (where `bootstrap_wizard_arena` is called), import and instantiate `ArenaUi`.
- Wire `handle_arena_input` into the existing input handling for the arena mode.
- Wire `render_controls_panel` into the existing rendering, placing it in the right 30% of the terminal.
- Note: The existing TUI does NOT run Bevy systems. The brush, catastrophe, and snapshot operations happen directly on the GameState's internal data. The TUI arena path does not have CaGrid as a Bevy Resource - it would need to operate on whatever grid representation exists in the TUI path. Check how the existing TUI arena path works and adapt accordingly. If the TUI arena does not have a CaGrid, create a standalone one for the arena scene.
  </action>
  <verify>
`cargo check -p omega-tui` compiles clean.
`cargo test -p omega-tui` passes (if any tests exist).
  </verify>
  <done>
TUI arena module provides keyboard-driven catastrophe triggers, elemental brush painting, monster spawner list, snapshot/restore, and traffic-light performance HUD. Integrated into existing TUI arena game loop.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement Bevy arena controls panel</name>
  <files>
    crates/omega-bevy/src/presentation/arena_controls.rs
    crates/omega-bevy/src/presentation/mod.rs
  </files>
  <action>
Create `arena_controls.rs` with an egui-based control panel for the Bevy frontend:

1. **arena_controls_ui_system** Bevy system:
   - Parameters: `EguiContexts`, `ResMut<CaGrid>`, `ResMut<WindGrid>`, `ResMut<TurretMode>`, `Res<PerfSnapshot>`, `Res<RuntimeStatus>`, `ResMut<FrontendRuntime>`, `Res<ButtonInput<KeyCode>>`.
   - Only show when `status.app_state == AppState::WizardArena`.
   - Render `egui::Window::new("Arena Controls")` anchored bottom-right:
     a. **Catastrophe Suite** collapsing header:
        - Buttons: "Great Flood", "Forest Fire", "Windstorm", "Fuel Field".
        - Red button: "DOOMSDAY" with confirm dialog.
        - Each button calls `Catastrophe::method()` on CaGrid/WindGrid.
     b. **Turret Mode** toggle:
        - Checkbox bound to `turret.active`.
        - Slider for `turret.fire_rate_hz` (1.0 to 20.0).
     c. **Snapshot Controls**:
        - "Save Snapshot" button -> capture current grid state.
        - "Restore Snapshot" button -> restore most recent.
        - List showing snapshot labels.
        - Store snapshots in a `Local<SnapshotManager>` or a new `ArenaSnapshotState` Resource.
     d. **Performance** section (read-only):
        - Traffic light colored text.
        - FPS, CA timing, projectile/particle counts from PerfSnapshot.
        - Emergency status indicator.

2. Register SnapshotManager as a Resource (or use Local) - if Resource, insert in SimulationPlugin or a new ArenaControlsPlugin.

Update `mod.rs`:
- Add `pub mod arena_controls;`.
- Ensure `arena_controls_ui_system` is registered in the Bevy app. Add it to the existing presentation plugin or system registration. Check how `spawner_ui_system` is registered and follow the same pattern.
  </action>
  <verify>
`cargo check -p omega-bevy` compiles clean.
`cargo test -p omega-bevy` passes existing tests.
  </verify>
  <done>
Bevy arena gets egui control panel with catastrophe triggers, turret mode toggle/slider, snapshot save/restore, and read-only performance display. Registered alongside existing spawner system.
  </done>
</task>

</tasks>

<verification>
- `cargo check -p omega-tui -p omega-bevy` compiles clean.
- TUI arena shows controls panel with keyboard hints for catastrophes, brush modes, spawner, and perf HUD.
- Bevy arena shows egui window with buttons, toggles, and performance readout.
- Elemental brush injects elements into CA grid on mouse click/drag.
- All catastrophe scenarios are triggerable from both frontends.
</verification>

<success_criteria>
- TEST-01 satisfied: Wizard's Arena scene allows testing all elemental combinations via user input.
- Both TUI and Bevy frontends provide God Mode controls.
- Performance HUD shows traffic light health, live counters, and collapsible event log.
- Snapshot/restore works from both frontends.
</success_criteria>

<output>
After completion, create `.planning/phases/05-stress-test-wizards-arena-integration/05-03-SUMMARY.md`
</output>
