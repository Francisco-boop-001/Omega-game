---
phase: 01-core-elemental-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/omega-core/src/simulation/mod.rs
  - crates/omega-core/src/simulation/cell.rs
  - crates/omega-core/src/simulation/state.rs
  - crates/omega-core/src/simulation/grid.rs
  - crates/omega-core/src/simulation/neighborhood.rs
  - crates/omega-core/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "A CA grid can be created with configurable width and height"
    - "Each cell supports concurrent Solid, Liquid, and Gas layers"
    - "Cells store Heat, Wet, and Pressure as u8 values (0-255)"
    - "Double-buffered reads and writes prevent temporal artifacts"
    - "Moore neighborhood (8 neighbors) can be safely queried for any cell including edges"
  artifacts:
    - path: "crates/omega-core/src/simulation/cell.rs"
      provides: "Cell struct with multi-state layering and elemental properties"
      contains: "pub struct Cell"
    - path: "crates/omega-core/src/simulation/state.rs"
      provides: "Material enums for Solid, Liquid, Gas layers"
      contains: "pub enum Solid"
    - path: "crates/omega-core/src/simulation/grid.rs"
      provides: "CaGrid with double-buffered storage"
      contains: "pub struct CaGrid"
    - path: "crates/omega-core/src/simulation/neighborhood.rs"
      provides: "Safe neighbor access and Moore neighborhood iteration"
      contains: "pub fn moore_neighbors"
  key_links:
    - from: "crates/omega-core/src/simulation/grid.rs"
      to: "crates/omega-core/src/simulation/cell.rs"
      via: "CaGrid stores Vec<Cell>"
      pattern: "Vec<Cell>"
    - from: "crates/omega-core/src/simulation/cell.rs"
      to: "crates/omega-core/src/simulation/state.rs"
      via: "Cell uses Option<Solid>, Option<Liquid>, Option<Gas>"
      pattern: "Option<Solid>"
---

<objective>
Establish the foundational data model for the Cellular Automata elemental simulation: the Cell struct with multi-state layering, material enums, the double-buffered CaGrid resource, and safe neighborhood iteration utilities.

Purpose: All subsequent simulation logic (reactions, transitions, wind, diffusion) depends on these primitives. This plan creates the "atoms" of the simulation.
Output: A `simulation` module in `omega-core` with Cell, CaGrid, Material enums, and neighbor utilities, all unit-tested.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-core-elemental-system/01-RESEARCH.md
@crates/omega-core/src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define Cell struct and Material enums with multi-state layering</name>
  <files>
    crates/omega-core/src/simulation/mod.rs
    crates/omega-core/src/simulation/cell.rs
    crates/omega-core/src/simulation/state.rs
    crates/omega-core/src/lib.rs
  </files>
  <action>
Create the `simulation` module in `omega-core`.

**`crates/omega-core/src/lib.rs`:** Add `pub mod simulation;` declaration.

**`crates/omega-core/src/simulation/mod.rs`:** Module root, re-exports public API:
```rust
pub mod cell;
pub mod state;
pub mod grid;
pub mod neighborhood;
```

**`crates/omega-core/src/simulation/state.rs`:** Define material enums per the Layered System (locked decision):
- `Solid` enum: `Earth`, `Stone`, `Mud`, `Ash`, `Rubble`, `Grass`, `Wood` (Earth is structural base per Earth Anchoring decision; Grass/Wood needed for flash point thresholds)
- `Liquid` enum: `Water`, `Oil` (Oil for Gas Layering decision — gas layers exist over liquids)
- `Gas` enum: `Steam`, `Smoke`, `Fire` (Fire is gas-layer per research; Steam for evaporation)
- All enums: `#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]`
- Implement `Display` for each enum for future "Look" command vibe descriptions.
- Add `Solid::flash_point(&self) -> Option<u8>` method returning ignition thresholds: Grass=120, Wood=180, Stone=250. Return `None` for non-combustible materials (Mud, Ash, Rubble). Per locked decision: Grass < Wood < Stone.
- Add `Solid::is_combustible(&self) -> bool` convenience method.
- Add `Gas::is_flammable(&self) -> bool` (Fire=true, others=false).

**`crates/omega-core/src/simulation/cell.rs`:** Define the Cell struct per State Multiplicity decision:
```rust
#[derive(Debug, Clone, Copy, Default)]
pub struct Cell {
    pub solid: Option<Solid>,
    pub liquid: Option<Liquid>,
    pub gas: Option<Gas>,
    pub heat: u8,       // 0-255, Temperature
    pub wet: u8,        // 0-255, Saturation
    pub pressure: u8,   // 0-255, Density
}
```
- `Cell::default()` = all `None`, all values 0 (Air).
- `Cell::is_empty(&self) -> bool` — all layers None.
- `Cell::is_waterlogged(&self) -> bool` — `self.wet >= 255` (per Dousing Logic: max Wet grants fire immunity).
- `Cell::can_ignite(&self) -> bool` — not waterlogged AND no Steam gas layer AND has combustible solid.
- `Cell::visible_material(&self) -> &str` — returns display name prioritizing Gas > Liquid > Solid > "Air" (for rendering priority).

Add unit tests:
- Default cell is empty air
- Waterlogged detection at wet=255
- can_ignite returns false when waterlogged
- can_ignite returns false when Steam is present
- visible_material priority order
  </action>
  <verify>
Run `cargo test -p omega-core --lib simulation::cell` and `cargo test -p omega-core --lib simulation::state` — all tests pass. Run `cargo check -p omega-core` — no compilation errors.
  </verify>
  <done>
Cell struct exists with Option<Solid>, Option<Liquid>, Option<Gas> layers plus heat/wet/pressure u8 fields. Material enums include all required variants with flash point thresholds. Waterlogged and ignition logic implemented per locked decisions. All unit tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement CaGrid double-buffered resource and neighborhood utilities</name>
  <files>
    crates/omega-core/src/simulation/grid.rs
    crates/omega-core/src/simulation/neighborhood.rs
  </files>
  <action>
**`crates/omega-core/src/simulation/grid.rs`:** Implement the double-buffered CA grid:
```rust
pub struct CaGrid {
    width: usize,
    height: usize,
    front: Vec<Cell>,  // Read buffer
    back: Vec<Cell>,   // Write buffer
}
```
- `CaGrid::new(width: usize, height: usize) -> Self` — allocates both buffers with `Cell::default()`.
- `CaGrid::width(&self) -> usize` and `height(&self) -> usize` accessors.
- `CaGrid::get(&self, x: usize, y: usize) -> &Cell` — reads from front buffer. Panics if out of bounds (debug assert).
- `CaGrid::get_checked(&self, x: usize, y: usize) -> Option<&Cell>` — bounds-checked read from front buffer.
- `CaGrid::set(&mut self, x: usize, y: usize, cell: Cell)` — writes to back buffer.
- `CaGrid::swap_buffers(&mut self)` — `std::mem::swap(&mut self.front, &mut self.back)` then copy front to back so back starts as current state for next frame. This prevents stale data from the previous-previous frame leaking through.
- `CaGrid::in_bounds(&self, x: isize, y: isize) -> bool` — bounds check for signed coordinates.
- `CaGrid::cell_count(&self) -> usize` — returns width * height.
- Use flat Vec with index math `y * width + x` for cache locality (Claude's discretion on layout).

Add unit tests:
- New grid has correct dimensions
- get/set write to back, read from front
- swap_buffers makes back writes visible via get
- Out-of-bounds returns None for get_checked
- in_bounds checks work for edge cases

**`crates/omega-core/src/simulation/neighborhood.rs`:** Safe neighbor access utilities:
- `pub fn get_neighbor(grid: &CaGrid, x: usize, y: usize, dx: isize, dy: isize) -> Cell` — returns `Cell::default()` for out-of-bounds (treat edges as Air per research recommendation).
- `pub fn moore_neighbors(grid: &CaGrid, x: usize, y: usize) -> [Cell; 8]` — collects all 8 Moore neighbors (NW, N, NE, W, E, SW, S, SE) using `get_neighbor`.
- `pub fn von_neumann_neighbors(grid: &CaGrid, x: usize, y: usize) -> [Cell; 4]` — collects 4 cardinal neighbors (N, S, E, W).
- `pub const MOORE_OFFSETS: [(isize, isize); 8]` — the 8 direction offsets.
- `pub const VON_NEUMANN_OFFSETS: [(isize, isize); 4]` — the 4 cardinal offsets.

Add unit tests:
- Corner cell (0,0) returns default for out-of-bounds neighbors
- Center cell returns correct 8 neighbors
- Von Neumann returns 4 cardinal neighbors
- Edge cells handle boundaries correctly
  </action>
  <verify>
Run `cargo test -p omega-core --lib simulation::grid` and `cargo test -p omega-core --lib simulation::neighborhood` — all tests pass. Run `cargo check -p omega-core` — no compilation errors.
  </verify>
  <done>
CaGrid provides double-buffered read/write with zero-cost swap. Neighborhood utilities safely handle all edge/corner cases returning Air for out-of-bounds. Flat Vec layout used for cache performance. All unit tests pass.
  </done>
</task>

</tasks>

<verification>
- `cargo check -p omega-core` compiles without errors
- `cargo test -p omega-core --lib simulation` — all tests pass
- Cell supports multi-state layering with Option<Solid/Liquid/Gas>
- CaGrid double-buffer prevents read-write conflicts
- Neighborhood handles edges safely (no panics at grid boundaries)
</verification>

<success_criteria>
- simulation module exists in omega-core with cell, state, grid, neighborhood submodules
- Cell struct has heat:u8, wet:u8, pressure:u8, Option<Solid>, Option<Liquid>, Option<Gas>
- CaGrid has front/back buffers with swap_buffers()
- Flash points defined: Grass=120, Wood=180, Stone=250
- Waterlogged detection at wet=255
- Moore neighborhood returns 8 neighbors safely for any coordinate
- All unit tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-elemental-system/01-01-SUMMARY.md`
</output>
