---
phase: 01-core-elemental-system
plan: 04
type: execute
wave: 4
depends_on: ["01-03"]
files_modified:
  - crates/omega-bevy/src/simulation/mod.rs
  - crates/omega-bevy/src/simulation/systems.rs
  - crates/omega-bevy/src/simulation/plugin.rs
  - crates/omega-bevy/src/lib.rs
  - crates/omega-bevy/Cargo.toml
autonomous: true

must_haves:
  truths:
    - "CA grid updates independently of frame rate via FixedUpdate at 64Hz"
    - "Double-buffer swap happens after all cell updates complete"
    - "CaGrid and WindGrid are accessible as Bevy Resources"
    - "The simulation plugin can be added to a Bevy App in one line"
    - "Wind updates run at a lower frequency than CA updates"
    - "Explosive displacement events are processed after cell updates"
  artifacts:
    - path: "crates/omega-bevy/src/simulation/plugin.rs"
      provides: "SimulationPlugin for Bevy App registration"
      contains: "pub struct SimulationPlugin"
    - path: "crates/omega-bevy/src/simulation/systems.rs"
      provides: "Bevy systems for CA update, buffer swap, wind, displacement"
      contains: "pub fn update_ca_cells"
  key_links:
    - from: "crates/omega-bevy/src/simulation/systems.rs"
      to: "crates/omega-core/src/simulation/reactions.rs"
      via: "Systems call compute_next_cell for each grid cell"
      pattern: "compute_next_cell"
    - from: "crates/omega-bevy/src/simulation/plugin.rs"
      to: "crates/omega-bevy/src/simulation/systems.rs"
      via: "Plugin registers systems in FixedUpdate schedule"
      pattern: "FixedUpdate.*update_ca_cells"
---

<objective>
Wire the pure simulation logic from omega-core into Bevy's ECS as Resources and Systems. Create a SimulationPlugin that registers the CA grid as a Resource, schedules updates in FixedUpdate at 64Hz, and orchestrates the update -> react -> displace -> swap pipeline.

Purpose: This bridges domain logic and engine integration. Without this, the simulation exists as pure functions but never runs. This plan makes it a live, ticking simulation inside Bevy.
Output: A SimulationPlugin that can be added to any Bevy App with `.add_plugins(SimulationPlugin::new(128, 128))`.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-core-elemental-system/01-CONTEXT.md
@.planning/phases/01-core-elemental-system/01-01-SUMMARY.md
@.planning/phases/01-core-elemental-system/01-02-SUMMARY.md
@.planning/phases/01-core-elemental-system/01-03-SUMMARY.md
@crates/omega-bevy/src/lib.rs
@crates/omega-bevy/Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Bevy systems for CA update pipeline</name>
  <files>
    crates/omega-bevy/src/simulation/mod.rs
    crates/omega-bevy/src/simulation/systems.rs
    crates/omega-bevy/src/lib.rs
  </files>
  <action>
**`crates/omega-bevy/src/lib.rs`:** Add `pub mod simulation;` declaration.

**`crates/omega-bevy/src/simulation/mod.rs`:** Module root:
```rust
pub mod systems;
pub mod plugin;
```

**`crates/omega-bevy/src/simulation/systems.rs`:** Bevy systems that drive the CA.

`pub fn update_ca_cells(mut grid: ResMut<CaGrid>, wind: Res<WindGrid>)`:
- Iterate all cells (0..height, 0..width).
- For each cell: read from front buffer via `grid.get(x, y)`.
- Collect Moore neighbors via `moore_neighbors(&grid, x, y)`.
- Call `compute_next_cell(&cell, &neighbors)` from omega-core.
- Apply wind effects via `apply_wind(&grid, &wind, x, y)`.
- Write result to back buffer via `grid.set(x, y, result)`.
- Note: grid width/height must be captured before mutable borrow. Use a pattern like:
  ```rust
  let (w, h) = (grid.width(), grid.height());
  for y in 0..h {
      for x in 0..w {
          // ...
      }
  }
  ```

`pub fn process_explosions(mut grid: ResMut<CaGrid>)`:
- After cell updates, scan for explosion triggers.
- For each cell in the grid: call `check_explosion_trigger(&cell)`.
- Collect all DisplacementEvents.
- Apply each via `apply_explosive_displacement(&mut grid, &event)`.
- This runs AFTER update_ca_cells but BEFORE swap_buffers.

`pub fn swap_ca_buffers(mut grid: ResMut<CaGrid>)`:
- Call `grid.swap_buffers()`.
- Must run AFTER update_ca_cells AND process_explosions.

`pub fn apply_decay_system(mut grid: ResMut<CaGrid>, tick_counter: Res<SimulationTick>)`:
- Apply `apply_full_decay_cycle` to each cell.
- Pass `is_reclaim_tick = tick_counter.0 % 60 == 0` (Nature Reclaims every 60 ticks, approximately once per second at 64Hz).
- This runs in the update_ca_cells pass (can be combined or separate system).

Define `SimulationTick(u64)` as a Bevy Resource, incremented each FixedUpdate.

`pub fn increment_tick(mut tick: ResMut<SimulationTick>)`:
- `tick.0 = tick.0.wrapping_add(1)`.

System ordering in FixedUpdate:
```
increment_tick -> update_ca_cells -> process_explosions -> swap_ca_buffers
```
Use `.chain()` or explicit `.after()` ordering to guarantee this sequence.
  </action>
  <verify>
`cargo check -p omega-bevy` — compiles without errors. System function signatures are compatible with Bevy's system parameter extraction.
  </verify>
  <done>
Bevy systems exist for: tick increment, CA cell update (reads front, writes back), explosion processing, and buffer swap. System ordering guarantees update -> explode -> swap sequence. Decay integrated with configurable Nature Reclaims frequency.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create SimulationPlugin with FixedUpdate registration</name>
  <files>
    crates/omega-bevy/src/simulation/plugin.rs
    crates/omega-bevy/Cargo.toml
  </files>
  <action>
**`crates/omega-bevy/Cargo.toml`:** Verify omega-core dependency exists (it should from workspace). No new external dependencies needed.

**`crates/omega-bevy/src/simulation/plugin.rs`:** The Bevy plugin that wires everything together.

```rust
use bevy_app::{App, Plugin, FixedUpdate};
use bevy_ecs::schedule::IntoSystemConfigs;
use omega_core::simulation::grid::CaGrid;
use omega_core::simulation::wind::WindGrid;

pub struct SimulationPlugin {
    pub width: usize,
    pub height: usize,
    pub tick_rate_hz: f64,
}

impl SimulationPlugin {
    pub fn new(width: usize, height: usize) -> Self {
        Self { width, height, tick_rate_hz: 64.0 }
    }

    pub fn with_tick_rate(mut self, hz: f64) -> Self {
        self.tick_rate_hz = hz;
        self
    }
}
```

Implement `Plugin for SimulationPlugin`:
- Insert Resources:
  - `CaGrid::new(self.width, self.height)`
  - `WindGrid::new(self.width, self.height)`
  - `SimulationTick(0)`
  - `Time::<Fixed>::from_hz(self.tick_rate_hz)` — set fixed timestep to 64Hz (per research: avoids pathological 60Hz interaction).
- Register systems in `FixedUpdate` schedule with ordering:
  ```rust
  app.add_systems(FixedUpdate, (
      increment_tick,
      update_ca_cells.after(increment_tick),
      process_explosions.after(update_ca_cells),
      swap_ca_buffers.after(process_explosions),
  ));
  ```

Usage example (for documentation, not code):
```rust
// In main app setup:
app.add_plugins(SimulationPlugin::new(128, 128));
// Grid is now a Resource, updating at 64Hz in FixedUpdate
```

Add a simple integration test (can be in same file under `#[cfg(test)]`):
- Create a minimal Bevy App with SimulationPlugin
- Verify CaGrid resource exists with correct dimensions
- Verify WindGrid resource exists
- Verify SimulationTick resource exists at 0
  </action>
  <verify>
`cargo check -p omega-bevy` — compiles without errors. `cargo test -p omega-bevy --lib simulation` — integration test passes. Plugin can be instantiated and added to a Bevy App.
  </verify>
  <done>
SimulationPlugin exists and registers CaGrid, WindGrid, and SimulationTick as Resources. FixedUpdate at 64Hz runs the complete pipeline: tick -> update -> explode -> swap. Plugin is configurable (grid size, tick rate). Integration test confirms resource registration.
  </done>
</task>

</tasks>

<verification>
- `cargo check -p omega-bevy` compiles clean
- `cargo test -p omega-bevy --lib simulation` passes
- `cargo test -p omega-core --lib simulation` still passes (no regressions)
- SimulationPlugin registers CaGrid and WindGrid as Resources
- Systems run in FixedUpdate with correct ordering
- 64Hz tick rate configured
- Grid dimensions configurable via SimulationPlugin::new(w, h)
</verification>

<success_criteria>
- SimulationPlugin::new(128, 128) adds complete CA simulation to Bevy App
- FixedUpdate schedule at 64Hz with ordered pipeline: tick -> update -> explode -> swap
- CaGrid, WindGrid, SimulationTick available as Bevy Resources
- No frame-rate dependency in simulation updates
- Explosion processing happens between cell updates and buffer swap
- Nature Reclaims runs every ~1 second (60 ticks)
- cargo check and cargo test pass for both omega-core and omega-bevy
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-elemental-system/01-04-SUMMARY.md`
</output>
