---
phase: 01-core-elemental-system
plan: 02
type: tdd
wave: 2
depends_on: ["01-01"]
files_modified:
  - crates/omega-core/src/simulation/reactions.rs
  - crates/omega-core/src/simulation/transitions.rs
  - crates/omega-core/src/simulation/mod.rs
autonomous: true

must_haves:
  truths:
    - "Applying high Heat to a Wet cell produces Steam"
    - "Applying Water to an Earth cell produces Mud"
    - "Fire cannot ignite waterlogged (wet=255) cells"
    - "Fireballs bypass gradual heat-up and trigger instant ignition"
    - "Torches cause gradual heat accumulation toward flash points"
    - "State transitions have hysteresis margins preventing oscillation"
    - "Burning combustible solids produces Ash"
  artifacts:
    - path: "crates/omega-core/src/simulation/reactions.rs"
      provides: "Reaction lookup and combination logic"
      exports: ["apply_reactions"]
      contains: "pub fn apply_reactions"
    - path: "crates/omega-core/src/simulation/transitions.rs"
      provides: "State transition logic with flash points and thresholds"
      exports: ["apply_heat", "apply_transitions"]
      contains: "pub fn apply_heat"
  key_links:
    - from: "crates/omega-core/src/simulation/reactions.rs"
      to: "crates/omega-core/src/simulation/cell.rs"
      via: "Reads Cell state, returns new Cell"
      pattern: "fn apply_reactions.*Cell"
    - from: "crates/omega-core/src/simulation/transitions.rs"
      to: "crates/omega-core/src/simulation/state.rs"
      via: "Uses flash_point() and Material enums for threshold checks"
      pattern: "flash_point"
---

<objective>
Implement state transition logic with intensity thresholds and reaction rules. This is the "brain" of the CA — given a cell's current state and its environment, what happens next?

Purpose: Without reactions and transitions, the grid is inert data. This plan makes the simulation reactive per the "Violent vs. Smoldering" philosophy.
Output: Tested reaction and transition functions that transform cells based on their Heat/Wet/Pressure values and material composition.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-core-elemental-system/01-CONTEXT.md
@.planning/phases/01-core-elemental-system/01-RESEARCH.md
@.planning/phases/01-core-elemental-system/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement state transitions with flash points and threshold hysteresis</name>
  <files>
    crates/omega-core/src/simulation/transitions.rs
    crates/omega-core/src/simulation/mod.rs
  </files>
  <action>
This is a TDD task. Write tests FIRST, then implement.

**Add `pub mod transitions;` to mod.rs.**

**`crates/omega-core/src/simulation/transitions.rs`:** State transition logic implementing the "Violent vs. Smoldering" philosophy.

**RED — Write failing tests first:**
```rust
#[cfg(test)]
mod tests {
    // Violent ignition: Fireball bypasses gradual heat, instant flash
    // test_fireball_ignites_grass: apply_heat(grass_cell, 200, violent=true) -> gas=Some(Fire), heat=255
    // test_fireball_ignites_wood: apply_heat(wood_cell, 200, violent=true) -> gas=Some(Fire)
    // test_fireball_fails_on_stone: apply_heat(stone_cell, 200, violent=true) -> no change (200 < 250 flash point)

    // Gradual ignition: Torch accumulates heat
    // test_torch_accumulates_heat: apply_heat(grass_cell{heat:100}, 30, violent=false) -> heat=130, still Grass (130 > 120 flash point, so ignites)
    // test_torch_below_flash_point: apply_heat(wood_cell{heat:100}, 30, violent=false) -> heat=130, still Wood (130 < 180)

    // Hysteresis: 20-degree margin between forward/reverse transitions
    // test_water_to_steam_at_200: cell with liquid=Water, heat=201 -> liquid=None, gas=Steam
    // test_steam_stays_steam_at_185: cell with gas=Steam, heat=185 -> still Steam (reverse at 180)
    // test_steam_to_water_at_179: cell with gas=Steam, heat=179 -> gas=None, liquid=Water

    // Dousing: waterlogged cells immune to fire
    // test_waterlogged_blocks_ignition: apply_heat(grass_cell{wet:255}, 255, violent=true) -> no Fire

    // Combustion produces ash
    // test_burning_grass_produces_ash: grass cell with gas=Fire, after burn cycle -> solid=Ash
    // test_burning_wood_produces_ash: wood cell with gas=Fire, after burn cycle -> solid=Ash
}
```

**GREEN — Implement:**

`pub fn apply_heat(cell: &Cell, amount: u8, is_violent: bool) -> Cell`:
- If cell is waterlogged (wet >= 255), return cell unchanged (Dousing Logic locked decision).
- If `is_violent` AND cell has combustible solid with flash_point <= amount:
  - Set gas = Some(Gas::Fire), heat = 255 (instant ignition, Violent philosophy).
- If NOT violent:
  - Accumulate heat: `heat = heat.saturating_add(amount)`.
  - If heat >= solid's flash_point, set gas = Some(Gas::Fire).
- Return modified cell.

`pub fn apply_transitions(cell: &Cell, neighbors: &[Cell; 8]) -> Cell`:
- Apply hysteresis-aware state transitions. Check in priority order:
  1. **Evaporation:** If liquid=Water AND heat > 200 -> liquid=None, gas=Steam, heat -= 50 (consumes energy). Forward threshold: 200.
  2. **Condensation:** If gas=Steam AND heat < 180 -> gas=None, liquid=Water. Reverse threshold: 180. (20-degree hysteresis margin per research).
  3. **Mud formation:** If solid=Earth AND wet > 150 -> solid=Mud.
  4. **Mud drying:** If solid=Mud AND wet < 100 -> solid=Earth. (50-point hysteresis).
  5. **Combustion completion:** If gas=Fire AND solid is combustible AND heat < 50 (fuel exhausted) -> gas=None, solid=Ash.
  6. **Fire extinguish:** If gas=Fire AND wet >= 200 -> gas=None, heat /= 2, wet -= 100. (Dousing: heavy water extinguishes fire).
- Return modified cell.

`pub fn apply_decay(cell: &Cell, decay_rate: u8) -> Cell`:
- Heat decays by decay_rate (saturating_sub). Per locked decision: Heat is "Residual" and decays slowly.
- Wet decays by decay_rate / 2.
- Return modified cell.
  </action>
  <verify>
Run `cargo test -p omega-core --lib simulation::transitions` — RED: all tests fail initially. Implement functions. Run again — GREEN: all tests pass. `cargo check -p omega-core` compiles clean.
  </verify>
  <done>
apply_heat handles both violent (Fireball=instant) and gradual (Torch=accumulate) ignition with flash point checks. apply_transitions handles evaporation, condensation, mud formation, combustion, and fire extinguish with hysteresis margins. Waterlogged cells block ignition. All tests pass via TDD.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement reaction system with combination lookup</name>
  <files>
    crates/omega-core/src/simulation/reactions.rs
    crates/omega-core/src/simulation/mod.rs
  </files>
  <action>
This is a TDD task. Write tests FIRST, then implement.

**Add `pub mod reactions;` to mod.rs.**

**`crates/omega-core/src/simulation/reactions.rs`:** Reaction logic that considers cell state + neighbors.

**RED — Write failing tests first:**
```rust
#[cfg(test)]
mod tests {
    // Core reactions (ELE-04)
    // test_fire_plus_water_makes_steam: cell{gas=Fire} + neighbor{liquid=Water} -> gas=Steam in neighbor area
    // test_water_plus_earth_makes_mud: cell{liquid=Water} + cell{solid=Earth} -> solid=Mud
    // test_fire_spreads_to_adjacent_combustible: cell{gas=Fire} neighbor{solid=Grass} -> neighbor gets heat increase

    // Neighbor influence
    // test_hot_neighbor_transfers_heat: cell{heat=0} with hot neighbor{heat=200} -> cell heat increases
    // test_wet_neighbor_transfers_moisture: cell{wet=0} near cell{liquid=Water} -> wet increases

    // Pressure from combustion
    // test_fire_generates_pressure: cell{gas=Fire, solid=Wood} -> pressure increases
    // test_pressure_dissipates_without_source: cell{pressure=100, gas=None} -> pressure decreases

    // Edge cases
    // test_empty_cell_no_reaction: Cell::default() -> no changes
    // test_multiple_reactions_priority: cell with both fire and water conditions -> water wins (extinguish)
}
```

**GREEN — Implement:**

`pub fn apply_reactions(cell: &Cell, neighbors: &[Cell; 8]) -> Cell`:
- This is the per-cell reaction function called during CA update.
- Priority order (highest first):
  1. **Extinguish:** If cell has Fire AND any neighbor provides significant water (wet > 150) -> extinguish fire, increase steam.
  2. **Spread fire:** If cell has combustible solid AND any neighbor has Fire AND cell can_ignite() -> increase heat by 20 per burning neighbor.
  3. **Moisture transfer:** If any neighbor has liquid=Water -> increase cell wet by small amount (diffusion). Use average of neighbor wet values with conductivity factor k=0.1.
  4. **Heat transfer (diffusion):** Apply Laplacian-based heat diffusion. New heat += k * (avg_neighbor_heat - cell_heat). k=0.1 for thermal conductivity. Use saturating arithmetic.
  5. **Pressure from combustion:** If cell has Fire AND combustible solid, increase pressure by fuel_density factor. High combustible concentrations trigger higher pressure (Combustion Mechanics locked decision).
  6. **Pressure dissipation:** Pressure decays toward 0 when no active source.

`pub fn compute_next_cell(cell: &Cell, neighbors: &[Cell; 8]) -> Cell`:
- This is the master function that chains: apply_reactions -> apply_transitions.
- Order matters: reactions modify values FIRST, then transitions check thresholds.
- Returns the fully computed next-state cell.

`pub fn count_burning_neighbors(neighbors: &[Cell; 8]) -> u8`:
- Helper: counts neighbors with gas=Some(Gas::Fire).

`pub fn avg_neighbor_heat(neighbors: &[Cell; 8]) -> u8`:
- Helper: average heat across all 8 neighbors.
  </action>
  <verify>
Run `cargo test -p omega-core --lib simulation::reactions` — RED then GREEN via TDD. Run `cargo test -p omega-core --lib simulation` — ALL simulation tests pass. `cargo check -p omega-core` compiles clean.
  </verify>
  <done>
Reaction system handles Fire+Water=Steam, Water+Earth=Mud, fire spread, heat diffusion, moisture transfer, and pressure from combustion. compute_next_cell chains reactions then transitions for the complete per-cell update pipeline. All tests pass via TDD.
  </done>
</task>

</tasks>

<verification>
- `cargo test -p omega-core --lib simulation` — all tests pass
- Fire + Water = Steam reaction works
- Water + Earth = Mud reaction works
- Violent ignition (Fireball) bypasses gradual heat-up
- Gradual ignition (Torch) accumulates toward flash points
- Waterlogged cells block fire
- Hysteresis prevents state oscillation
- Heat diffusion spreads based on neighbor average
</verification>

<success_criteria>
- apply_heat differentiates violent (instant) vs gradual (accumulate) ignition
- apply_transitions handles evaporation, condensation, mud, combustion with hysteresis
- apply_reactions implements heat diffusion, moisture transfer, fire spread, pressure
- compute_next_cell chains reactions -> transitions as complete update pipeline
- Flash points honored: Grass=120, Wood=180, Stone=250
- Waterlogged (wet=255) blocks ignition
- Hysteresis margin of 20+ degrees on all reversible transitions
- All tests written RED-first, then GREEN
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-elemental-system/01-02-SUMMARY.md`
</output>
