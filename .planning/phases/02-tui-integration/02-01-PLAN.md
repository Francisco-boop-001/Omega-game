---
phase: 02-tui-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/omega-tui/src/color_adapter.rs
  - crates/omega-tui/src/lib.rs
  - crates/omega-tui/Cargo.toml
autonomous: true

must_haves:
  truths:
    - "StyleCache resolves any ColorId to a ratatui::Style in O(1)"
    - "Terminal capability is detected at startup and colors are adapted accordingly"
    - "NO_COLOR environment variable disables all colors (returns unstyled defaults)"
    - "App struct holds a StyleCache that can be used by render functions"
  artifacts:
    - path: "crates/omega-tui/src/color_adapter.rs"
      provides: "StyleCache struct with precomputed HashMap<ColorId, Style>"
      exports: ["StyleCache"]
    - path: "crates/omega-tui/src/lib.rs"
      provides: "App struct with theme and style_cache fields"
      contains: "style_cache"
  key_links:
    - from: "crates/omega-tui/src/color_adapter.rs"
      to: "omega_core::color::ColorTheme"
      via: "StyleCache::from_theme() calls theme.resolve()"
      pattern: "theme\\.resolve"
    - from: "crates/omega-tui/src/color_adapter.rs"
      to: "omega_core::color::ColorCapability"
      via: "capability.adapt() converts ColorSpec to terminal-appropriate level"
      pattern: "capability\\.adapt"
    - from: "crates/omega-tui/src/lib.rs"
      to: "crates/omega-tui/src/color_adapter.rs"
      via: "App holds StyleCache, passes to render functions"
      pattern: "style_cache"
---

<objective>
Create the ratatui style adapter that converts Phase 1's ColorTheme + ColorId into precomputed ratatui::Style values, with terminal capability adaptation and NO_COLOR support. Integrate this into the App struct so all render functions can access cached styles.

Purpose: This is the foundation layer for all colored rendering. Without a fast O(1) style lookup, every render function would need to resolve colors per-frame, violating PERF-02 and PERF-03.

Output: color_adapter.rs module with StyleCache, updated App struct with theme integration
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/1-foundation/1-complete-SUMMARY.md

# Phase 1 source files needed for understanding the API
@crates/omega-core/src/color/mod.rs
@crates/omega-core/src/color/color_id.rs
@crates/omega-core/src/color/theme.rs
@crates/omega-core/src/color/capability.rs
@crates/omega-core/src/color/color_spec.rs
@crates/omega-core/src/color/hex_color.rs

# Current TUI crate
@crates/omega-tui/src/lib.rs
@crates/omega-tui/Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create StyleCache adapter in color_adapter.rs</name>
  <files>crates/omega-tui/src/color_adapter.rs</files>
  <action>
Create a new module `crates/omega-tui/src/color_adapter.rs` with a `StyleCache` struct that:

1. **StyleCache struct**: Holds a `HashMap<ColorId, ratatui::style::Style>` for O(1) lookups. Also store the detected `ColorCapability` and a `colors_enabled: bool` flag.

2. **StyleCache::new(theme: &ColorTheme, capability: ColorCapability) -> Self**:
   - If capability is `ColorCapability::None`, set `colors_enabled = false` and store an empty HashMap (all lookups return `Style::default()`).
   - Otherwise, iterate over ALL ColorId variants (use a helper function `all_color_ids()` that returns a Vec of all 63 ColorId variants).
   - For each ColorId, call `theme.resolve(&color_id)`. If Some((fg_hex, bg_hex)):
     - Convert HexColor fg to ColorSpec via `ColorSpec::from(fg_hex)`
     - Adapt using `capability.adapt(&fg_spec)` to get terminal-appropriate ColorSpec
     - Convert adapted ColorSpec to `ratatui::style::Color`:
       - `ColorSpec::Rgb { r, g, b }` -> `Color::Rgb(r, g, b)`
       - `ColorSpec::Indexed(idx)` -> `Color::Indexed(idx)`
       - `ColorSpec::Ansi(ansi)` -> Map AnsiColor variants to ratatui's `Color::Black`, `Color::Red`, etc. (map BrightRed -> `Color::LightRed`, BrightGreen -> `Color::LightGreen`, etc.)
     - Do the same for bg_hex
     - Create `Style::default().fg(ratatui_fg).bg(ratatui_bg)` and insert into HashMap
   - If resolve returns None for a ColorId, skip it (the lookup will return default style).

3. **StyleCache::get(&self, color_id: &ColorId) -> Style**:
   - If `!self.colors_enabled`, return `Style::default()`.
   - Otherwise, look up in HashMap, falling back to `Style::default()`.

4. **StyleCache::get_fg(&self, color_id: &ColorId) -> Style**:
   - Same as get() but only applies the foreground color (no background). This is useful for inline text coloring where background should inherit from the widget.

5. **Helper function `all_color_ids() -> Vec<ColorId>`**: Returns all 63 ColorId variants by iterating through each enum. This is verbose but explicit -- list every variant:
   - EntityColorId::Player
   - EntityColorId::Monster(MonsterColorId::HostileUndead) through all 8 monster variants
   - EntityColorId::Item(ItemRarityColorId::Common) through all 5 rarity variants
   - EntityColorId::Terrain(TerrainColorId::WallStone) through all 13 terrain variants
   - UiColorId::HealthHigh through all 16 UI variants
   - EffectColorId::Fire through all 11 effect variants
   - EnvironmentColorId::LightTorch through all 5 environment variants

6. **Helper function `colorspec_to_ratatui(spec: &ColorSpec) -> Color`**: Converts omega-core's ColorSpec to ratatui::style::Color. Map AnsiColor enum variants:
   - AnsiColor::Black -> Color::Black
   - AnsiColor::Red -> Color::Red
   - AnsiColor::Green -> Color::Green
   - AnsiColor::Yellow -> Color::Yellow
   - AnsiColor::Blue -> Color::Blue
   - AnsiColor::Magenta -> Color::Magenta
   - AnsiColor::Cyan -> Color::Cyan
   - AnsiColor::White -> Color::White
   - AnsiColor::BrightBlack -> Color::DarkGray
   - AnsiColor::BrightRed -> Color::LightRed
   - AnsiColor::BrightGreen -> Color::LightGreen
   - AnsiColor::BrightYellow -> Color::LightYellow
   - AnsiColor::BrightBlue -> Color::LightBlue
   - AnsiColor::BrightMagenta -> Color::LightMagenta
   - AnsiColor::BrightCyan -> Color::LightCyan
   - AnsiColor::BrightWhite -> Color::White

7. **Unit tests**:
   - Test that StyleCache::new with a theme produces non-empty map
   - Test that StyleCache::get returns Style::default() for unknown ColorIds
   - Test that StyleCache with ColorCapability::None returns default styles for everything
   - Test colorspec_to_ratatui conversions for RGB, Indexed, and Ansi variants

Do NOT add style modifiers (bold, italic) yet -- those will be added per-panel in Plan 02 where context-specific styling is applied.
  </action>
  <verify>
`cargo check -p omega-tui` compiles without errors. Unit tests in color_adapter.rs pass with `cargo test -p omega-tui color_adapter`.
  </verify>
  <done>
StyleCache::new() precomputes styles for all 63 ColorId variants. StyleCache::get() returns O(1) ratatui::Style. ColorCapability::None produces unstyled output. All conversions from ColorSpec to ratatui::Color are correct.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate StyleCache into App struct and startup</name>
  <files>crates/omega-tui/src/lib.rs, crates/omega-tui/Cargo.toml</files>
  <action>
1. **Cargo.toml**: Add `clap` dependency for CLI parsing (will be used in Plan 03, but adding now avoids modifying Cargo.toml twice):
   ```toml
   clap = { version = "4", features = ["derive"] }
   ```
   Also add `serde_json` from workspace if not already present (it's a workspace dep).

2. **lib.rs module declaration**: Add `pub mod color_adapter;` near the top of the file, after existing use statements. Re-export `StyleCache`: `pub use color_adapter::StyleCache;`.

3. **App struct**: Add three new fields:
   - `pub theme: omega_core::color::ColorTheme` - The active color theme
   - `pub style_cache: StyleCache` - Precomputed styles from the theme
   - `pub capability: omega_core::color::ColorCapability` - Detected terminal capability

4. **App::new() and App::new_with_mode()**: After creating bootstrap state, perform theme loading:
   - Load the default theme ("classic") using `ColorTheme::load_from_file()`. The theme files are at `crates/omega-content/themes/classic.toml`. Use a relative path or embed the TOML. Since omega-content already provides content loading, check if there's an existing mechanism. If not, use `include_str!` to embed the classic theme TOML at compile time:
     ```rust
     const CLASSIC_THEME_TOML: &str = include_str!("../../omega-content/themes/classic.toml");
     ```
     Parse with `ColorTheme::from_toml(CLASSIC_THEME_TOML).unwrap_or_else(|_| /* fallback */)`.
   - Detect capability: `let capability = ColorCapability::detect();`
   - Create StyleCache: `let style_cache = StyleCache::new(&theme, capability);`

5. **App::with_options()**: Add optional theme parameter. Keep backward compatibility by providing a builder method or separate constructor. Add a new method:
   ```rust
   pub fn with_theme(mut self, theme: ColorTheme) -> Self {
       self.style_cache = StyleCache::new(&theme, self.capability);
       self.theme = theme;
       self
   }
   ```

6. **Default and test constructors**: Update `App::default()` and `App::new()` to initialize theme, style_cache, and capability. Use `ColorCapability::detect()` for live usage. For test scenarios, provide `App::with_capability(cap: ColorCapability)` or just use `ColorCapability::default()` (Ansi16).

7. **render_frame signature**: Update `render_frame(frame: &mut Frame, app: &App)` to remain as-is (it already takes `&App`, which now carries `style_cache`). No signature change needed -- render functions access `app.style_cache`.

8. **Backward compatibility for tests**: Existing tests construct App without theme. Ensure all existing App constructors work by initializing with the embedded classic theme and `ColorCapability::default()`.

9. **Verify all existing tests still pass** -- no rendering behavior should change yet (colors are added in Plan 02).

IMPORTANT: Do NOT change any render function output yet. Only add the infrastructure. All existing tests must pass unchanged.
  </action>
  <verify>
`cargo check -p omega-tui` compiles. `cargo test -p omega-tui` passes all existing tests (no behavior change). The App struct has `theme`, `style_cache`, and `capability` fields.
  </verify>
  <done>
App struct carries ColorTheme, StyleCache, and ColorCapability. Default App loads classic theme via include_str!. ColorCapability::detect() runs at startup. All existing tests pass unchanged.
  </done>
</task>

</tasks>

<verification>
1. `cargo check -p omega-tui` compiles cleanly
2. `cargo test -p omega-tui` -- all existing tests pass (zero regressions)
3. `cargo test -p omega-tui color_adapter` -- new adapter tests pass
4. StyleCache contains entries for all resolvable ColorId variants
5. NO_COLOR scenario: StyleCache returns Style::default() for all lookups
</verification>

<success_criteria>
- color_adapter.rs exists with StyleCache struct
- App struct holds theme, style_cache, capability
- Default app loads classic theme at startup
- All 63 ColorId variants are precomputed to ratatui::Style
- ColorCapability adaptation works (RGB, 256, 16, None)
- Zero test regressions
</success_criteria>

<output>
After completion, create `.planning/phases/02-tui-integration/02-01-SUMMARY.md`
</output>
