---
phase: 02-tui-integration
plan: 03
type: execute
wave: 3
depends_on: ["02-02"]
files_modified:
  - crates/omega-tui/src/bin/omega-tui-app.rs
  - crates/omega-tui/src/lib.rs
  - crates/omega-tui/src/color_adapter.rs
autonomous: false

must_haves:
  truths:
    - "Users can select a theme via --theme CLI option at startup"
    - "Invalid theme name shows helpful error with available options"
    - "Users can switch themes at runtime with a keybinding without restart"
    - "NO_COLOR environment variable produces monochrome output"
    - "16-color fallback mode works on limited terminals"
  artifacts:
    - path: "crates/omega-tui/src/bin/omega-tui-app.rs"
      provides: "CLI --theme option using clap"
      contains: "--theme"
    - path: "crates/omega-tui/src/lib.rs"
      provides: "Runtime theme switching via keybinding"
      contains: "switch_theme"
  key_links:
    - from: "crates/omega-tui/src/bin/omega-tui-app.rs"
      to: "ColorTheme::from_toml / load_from_file"
      via: "CLI --theme option loads theme before rendering"
      pattern: "theme.*load\\|from_toml"
    - from: "crates/omega-tui/src/lib.rs"
      to: "StyleCache::new"
      via: "switch_theme rebuilds StyleCache from new theme"
      pattern: "StyleCache::new"
---

<objective>
Add CLI theme selection, runtime theme switching, and visual verification. Users can choose themes at startup via `--theme` and switch at runtime via a keybinding.

Purpose: Completes the Phase 2 user-facing features (TUI-04, TUI-05) and validates the entire color integration visually.

Output: CLI integration, runtime switching, human-verified colored TUI
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-tui-integration/02-01-SUMMARY.md
@.planning/phases/02-tui-integration/02-02-SUMMARY.md

# Source files
@crates/omega-tui/src/bin/omega-tui-app.rs
@crates/omega-tui/src/lib.rs
@crates/omega-tui/src/color_adapter.rs
@crates/omega-content/themes/classic.toml
@crates/omega-content/themes/accessible.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add --theme CLI option and runtime theme switching</name>
  <files>crates/omega-tui/src/bin/omega-tui-app.rs, crates/omega-tui/src/lib.rs, crates/omega-tui/src/color_adapter.rs</files>
  <action>
**1. CLI --theme option in omega-tui-app.rs:**

Add clap derive for command-line parsing. Create an `Args` struct:
```rust
use clap::Parser;

#[derive(Parser)]
#[command(name = "omega-tui", about = "Omega roguelike TUI client")]
struct Args {
    /// Color theme: "classic", "accessible", or path to a .toml file
    #[arg(long, default_value = "classic")]
    theme: String,
}
```

In `main()`, parse args before the game mode selection:
```rust
let args = Args::parse();
```

Create a `load_theme(name: &str) -> Result<ColorTheme>` function:
- If name is "classic": Load from embedded `include_str!("../../omega-content/themes/classic.toml")` and parse with `ColorTheme::from_toml()`
- If name is "accessible": Load from embedded `include_str!("../../omega-content/themes/accessible.toml")`
- If name ends with ".toml": Try `ColorTheme::load_from_file(Path::new(name))`
- Otherwise: Print error "Unknown theme '{}'. Available: classic, accessible, or provide a .toml file path." and exit with code 1.

Pass the loaded theme to `App` constructors. Update the app creation in the launcher loop to use:
```rust
let theme = load_theme(&args.theme)?;
// ... then pass theme to App
```

Update `run_ratatui_app_with_options` to accept an optional `ColorTheme` parameter, or add a new variant `run_ratatui_app_with_theme`. The cleanest approach: add a `theme: Option<ColorTheme>` parameter to `run_ratatui_app_with_options` (or create `run_ratatui_app_themed`). The app should use the provided theme or fall back to the embedded classic.

**2. Runtime theme switching in lib.rs:**

Add a `switch_theme(&mut self, theme: ColorTheme)` method to App:
```rust
pub fn switch_theme(&mut self, theme: ColorTheme) {
    self.style_cache = StyleCache::new(&theme, self.capability);
    self.theme = theme;
}
```

Add a theme cycling keybinding. Use `F10` as the theme switch key (it's unused in current key mappings). In `read_ui_key()`, add:
```rust
KeyCode::F(10) => Some(UiKey::ThemeCycle),
```

Add `ThemeCycle` variant to `UiKey` enum.

In `App::handle_key()` (before the modal interaction check), handle ThemeCycle:
```rust
UiKey::ThemeCycle => {
    self.cycle_theme();
    return;
}
```

Implement `cycle_theme()`:
```rust
fn cycle_theme(&mut self) {
    let next_theme_name = if self.theme.meta.name.contains("Classic") {
        "accessible"
    } else {
        "classic"
    };
    if let Ok(theme) = load_builtin_theme(next_theme_name) {
        self.switch_theme(theme);
        self.state.log.push(format!("Theme switched to: {}", self.theme.meta.name));
    }
}
```

**3. Embed both theme TOMLs in color_adapter.rs:**

Add embedded theme constants:
```rust
pub const CLASSIC_THEME_TOML: &str = include_str!("../../omega-content/themes/classic.toml");
pub const ACCESSIBLE_THEME_TOML: &str = include_str!("../../omega-content/themes/accessible.toml");
```

Provide a public `load_builtin_theme(name: &str) -> Result<ColorTheme, ThemeError>` function that parses these.

**4. Update UiKey enum and map_input:**

Add `ThemeCycle` to UiKey:
```rust
pub enum UiKey {
    // ... existing variants ...
    ThemeCycle,
}
```

In `map_input()`, add:
```rust
UiKey::ThemeCycle => UiAction::None, // Only handled in handle_key directly
```

**5. Status panel hint:** Add a line to the status panel showing current theme name and keybinding hint:
```
Theme: Classic (F10 to switch)
```

IMPORTANT: Preserve all existing keybindings. F10 is currently unmapped. Do NOT use keys that conflict with game input.

IMPORTANT: The `--help` output should document the --theme option via clap's derive macro.
  </action>
  <verify>
`cargo check -p omega-tui` compiles. `cargo test -p omega-tui` passes all existing tests. Running `cargo run -p omega-tui -- --help` shows --theme option. Running with `--theme nonexistent` shows helpful error.
  </verify>
  <done>
CLI --theme option selects theme at startup (classic/accessible/path.toml). Invalid theme shows actionable error. F10 cycles between built-in themes at runtime. Theme switch rebuilds StyleCache immediately. Status panel shows current theme name.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Visual verification of colored TUI</name>
  <files>crates/omega-tui/src/lib.rs</files>
  <action>
Human visual verification of the complete Phase 2 color integration. No code changes -- this is a verification-only checkpoint.

What was built across Plans 01-03:
- Style adapter converting ColorTheme to ratatui::Style (Plan 01)
- Colored map panel with entity-specific colors (Plan 02)
- Colored status panel with HP gradient (Plan 02)
- Colored log panel with severity colors (Plan 02)
- CLI --theme option (Plan 03 Task 1)
- Runtime theme switching with F10 (Plan 03 Task 1)
- NO_COLOR support (disables all colors)

Verification steps:
1. Run `cargo run -p omega-tui` and verify map panel shows colored glyphs, status panel shows HP gradient, log shows severity colors
2. Press F10 to switch themes -- colors should change immediately with no corruption
3. Test `cargo run -p omega-tui -- --theme accessible` starts with accessible theme
4. Test `cargo run -p omega-tui -- --theme nonexistent` shows error
5. Test `NO_COLOR=1 cargo run -p omega-tui` produces monochrome output
6. Verify no visual artifacts, flickering, or layout shifts
  </action>
  <verify>Human confirms visual output is correct and all features work as described.</verify>
  <done>Human has approved the visual output of the colored TUI, confirming all Phase 2 success criteria are met.</done>
</task>

</tasks>

<verification>
1. `cargo check -p omega-tui` compiles
2. `cargo test -p omega-tui` passes all tests
3. `cargo run -p omega-tui -- --help` documents --theme option
4. `cargo run -p omega-tui -- --theme accessible` starts with accessible theme
5. F10 switches theme at runtime without restart
6. `NO_COLOR=1 cargo run -p omega-tui` produces monochrome output
7. Human verification confirms visual quality
</verification>

<success_criteria>
- --theme CLI option works with "classic", "accessible", and file paths
- Invalid theme name shows helpful error listing available options
- F10 cycles between built-in themes at runtime
- Theme switch completes instantly (< 100ms) with no screen corruption
- NO_COLOR=1 disables all colors
- All existing tests pass
- Human verifies visual output is correct
</success_criteria>

<output>
After completion, create `.planning/phases/02-tui-integration/02-03-SUMMARY.md`
</output>
