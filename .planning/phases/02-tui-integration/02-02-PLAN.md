---
phase: 02-tui-integration
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - crates/omega-tui/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "Map panel renders entities with semantically colored glyphs (player, monsters, items, terrain)"
    - "Status panel shows HP in color gradient (green/yellow/red) and mana in blue"
    - "Log panel colors messages by severity (info/warning/danger/success)"
    - "Interaction panel highlights active prompts distinctly"
    - "Styles are batched per-entity-type, not per-character"
  artifacts:
    - path: "crates/omega-tui/src/lib.rs"
      provides: "Colored render functions using StyleCache"
      contains: "style_cache.get"
  key_links:
    - from: "crates/omega-tui/src/lib.rs render_map_panel"
      to: "StyleCache"
      via: "style_cache.get_fg() for entity-specific colors"
      pattern: "style_cache\\.get"
    - from: "crates/omega-tui/src/lib.rs render_status_panel"
      to: "StyleCache"
      via: "style_cache.get_fg() for health gradient and mana"
      pattern: "UiColorId::Health"
    - from: "crates/omega-tui/src/lib.rs render_log_panel"
      to: "StyleCache"
      via: "style_cache.get_fg() for message severity colors"
      pattern: "UiColorId::Message"
---

<objective>
Apply colors to all TUI render functions using the StyleCache from Plan 01. Convert plain-text Paragraph widgets to styled Text with colored Spans. Each panel gets semantically appropriate colors from the theme.

Purpose: This is the core visual transformation -- turning a monochrome TUI into a colorful one. Users will see colored dungeon maps, health bars, and message severity.

Output: Updated render functions in lib.rs that produce colored ratatui output
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-tui-integration/02-01-SUMMARY.md

# Source files
@crates/omega-tui/src/lib.rs
@crates/omega-tui/src/color_adapter.rs
@crates/omega-core/src/color/color_id.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Color the map panel with entity-specific styles</name>
  <files>crates/omega-tui/src/lib.rs</files>
  <action>
Refactor `render_map_panel` to return styled content instead of a plain String. The function currently returns `String` which is consumed by `Paragraph::new()`. Change the return type to `Vec<Line<'static>>` (ratatui styled lines) so the Paragraph can render colors.

**Signature change:**
```rust
fn render_map_panel(state: &GameState, style_cache: &StyleCache, view_width: u16, view_height: u16) -> Vec<Line<'static>>
```

**Implementation approach -- batch by row, not by character:**
For each row (y coordinate), build a `Vec<Span>` where consecutive characters with the same style are grouped into a single Span. This implements the "batch style changes" requirement from the pitfalls.

For each cell at (x, y), determine the appropriate ColorId:
- Targeting cursor (`X`): `UiColorId::Cursor`
- Projectile impact (`!`): `EffectColorId::Impact`
- Projectile path (`:`): `EffectColorId::MagicArcane`
- Player (`@`): `EntityColorId::Player`
- Monster (`m`): `MonsterColorId::HostileHumanoid` (default for generic monsters -- the game currently doesn't distinguish monster types on the map, so use a single hostile color)
- Ground item (`*`): `ItemRarityColorId::Common` (items on ground use common rarity color as we don't know rarity from the generic glyph)
- Objective marker (`o`): `UiColorId::Highlight`
- Objective route (`:`): `UiColorId::TextDim`
- Map glyphs: Determine by glyph character:
  - `#` (wall): `TerrainColorId::WallStone`
  - `.` (floor): `TerrainColorId::FloorStone`
  - `+` (door): `TerrainColorId::Door`
  - `<` (stairs up): `TerrainColorId::StairsUp`
  - `>` (stairs down): `TerrainColorId::StairsDown`
  - `~` (water): `TerrainColorId::Water`
  - `^` (lava): `TerrainColorId::Lava`
  - `"` or `,` (grass): `TerrainColorId::FloorGrass`
  - space (empty/unseen): No style (Style::default())
  - Other characters: `UiColorId::TextDefault`

**Batching algorithm:**
```rust
let mut spans: Vec<Span> = Vec::new();
let mut current_text = String::new();
let mut current_style = Style::default();
for each character in row:
    let style = determine_style(ch, ...);
    if style == current_style {
        current_text.push(ch);
    } else {
        if !current_text.is_empty() {
            spans.push(Span::styled(std::mem::take(&mut current_text), current_style));
        }
        current_text.push(ch);
        current_style = style;
    }
// flush remainder
if !current_text.is_empty() {
    spans.push(Span::styled(current_text, current_style));
}
lines.push(Line::from(spans));
```

**Update render_frame callsite**: Change from:
```rust
let map = Paragraph::new(render_map_panel(&app.state, map_view_width, map_view_height))
```
to:
```rust
let map = Paragraph::new(render_map_panel(&app.state, &app.style_cache, map_view_width, map_view_height))
```

**Update render_screen and render_to_string_with_ratatui**: These test helpers call render_frame indirectly, so they don't need changes. But ensure they still work -- the TestBackend will now see styled cells but the string extraction ignores styles.

IMPORTANT: Use `style_cache.get_fg()` (foreground only) for map characters, so the Paragraph's block background shows through. Only apply explicit background for terrain tiles that need it (like water or lava where bg color is meaningful).
  </action>
  <verify>
`cargo check -p omega-tui` compiles. `cargo test -p omega-tui` passes -- existing tests that check for panel content strings still work because render_to_string_with_ratatui extracts symbols, not styles.
  </verify>
  <done>
Map panel renders with colored glyphs: player in player color, monsters in hostile color, items in common color, walls/floors/doors in terrain colors. Styles are batched per-row for performance.
  </done>
</task>

<task type="auto">
  <name>Task 2: Color status, log, and interaction panels</name>
  <files>crates/omega-tui/src/lib.rs</files>
  <action>
Refactor the remaining render functions to produce styled output. Each function changes from returning `String` to returning `Vec<Line<'static>>` (or `Text<'static>`).

**1. render_status_panel(state, style_cache, save_slot) -> Vec<Line<'static>>**

Apply these colors:
- "Name:" label and value: `UiColorId::TextDefault`
- "HP: X/Y" line: Color the HP value based on percentage:
  - hp > 66% of max_hp: `UiColorId::HealthHigh` (green)
  - hp > 33% of max_hp: `UiColorId::HealthMedium` (yellow)
  - hp <= 33%: `UiColorId::HealthLow` (red)
  - The label "HP:" stays `UiColorId::TextDefault`, only the numbers get colored
- "Mana: X/Y": Color the mana value with `UiColorId::Mana`
- "State: Lost/Won": Color with `UiColorId::MessageDanger` for Lost, `UiColorId::MessageSuccess` for Won
- "Interaction:" line: Color the interaction description with `UiColorId::Highlight` if active, `UiColorId::TextDim` if "none"
- All other lines: `UiColorId::TextDefault`

Build lines using `Line::from(vec![Span::styled(...), Span::styled(...)])` for mixed-style lines.

**2. render_log_panel(state, style_cache, last_outcome) -> Vec<Line<'static>>**

Apply severity-based colors to log messages:
- Messages containing "died", "defeated", "killed", "damage", "hit you": `UiColorId::MessageDanger`
- Messages containing "warning", "caution", "careful": `UiColorId::MessageWarning`
- Messages containing "victory", "gained", "found", "success", "healed": `UiColorId::MessageSuccess`
- All other messages: `UiColorId::MessageInfo`
- Empty state "(no messages)": `UiColorId::TextDim`

For timeline lines from `renderable_timeline_lines()`, apply the same heuristic on the text content.

For event formatting (the `format_event` function), color by event type:
- `Event::PlayerDefeated`, `Event::MonsterAttacked`: `UiColorId::MessageDanger`
- `Event::VictoryAchieved`, `Event::MonsterDefeated`, `Event::PickedUp`: `UiColorId::MessageSuccess`
- `Event::Attacked`, `Event::Moved`: `UiColorId::MessageInfo`
- Other events: `UiColorId::TextDefault`

**3. render_interaction_panel(state, style_cache) -> Vec<Line<'static>>**

- Active prompt text: `UiColorId::Highlight`
- Help hint text: `UiColorId::TextDim`
- Input buffer display: `UiColorId::TextBold`
- "No active interaction.": `UiColorId::TextDim`

**4. render_inventory_panel(state, style_cache) -> Vec<Line<'static>>**

- "Pack: X/Y" header: `UiColorId::TextDefault`
- "(empty)": `UiColorId::TextDim`
- Item names: `UiColorId::TextDefault` (we don't have rarity info per-item in the current data model, so keep them neutral)
- Equipment summary: `UiColorId::TextDefault`, with "set" in `UiColorId::MessageSuccess` and "-" in `UiColorId::TextDim`
- "Ground here:" header: `UiColorId::TextDefault`

**5. render_terminal_panel(state, style_cache, save_slot) -> Vec<Line<'static>>**

- "You died!" / "You are victorious!": Use `UiColorId::MessageDanger` / `UiColorId::MessageSuccess`
- Stats and info: `UiColorId::TextDefault`
- Prompt line: `UiColorId::Highlight`

**6. Update all callsites in render_frame()**:

Update every `Paragraph::new(render_xxx(...))` call to pass `&app.style_cache` and accept the new `Vec<Line>` return type. The `Paragraph::new()` constructor accepts `Vec<Line>` directly.

IMPORTANT: Keep the `.wrap(Wrap { trim: false })` on all Paragraphs. The Text type from Vec<Line> works with wrapping.

IMPORTANT: Maintain backward compatibility for the test helper functions `render_screen()` and `render_to_string_with_ratatui()`. These extract cell symbols from the TestBackend buffer, so colored output doesn't break them -- the symbols remain the same, just styled.
  </action>
  <verify>
`cargo check -p omega-tui` compiles. `cargo test -p omega-tui` passes all existing tests. The render functions now return styled Vec<Line> instead of String. Paragraph widgets display colored text.
  </verify>
  <done>
All five panels (map, status, log, interaction, inventory) render with semantic colors. HP shows green/yellow/red gradient. Log messages colored by severity. Interaction prompts are highlighted. Terminal death/victory screens use appropriate danger/success colors.
  </done>
</task>

</tasks>

<verification>
1. `cargo check -p omega-tui` compiles
2. `cargo test -p omega-tui` passes all existing tests (string content unchanged, only styling added)
3. Map panel: player '@' uses Player color, walls '#' use WallStone color, monsters 'm' use HostileHumanoid color
4. Status panel: HP value colored by health percentage (green > 66%, yellow > 33%, red <= 33%)
5. Log panel: danger messages in red, success in green, info in blue
6. All panels use style_cache.get_fg() for foreground-only coloring
</verification>

<success_criteria>
- All render functions produce colored ratatui output
- HP gradient works (green/yellow/red by percentage)
- Log messages colored by severity heuristic
- Map entities colored by semantic type
- Style batching in map panel (not per-character)
- Zero test regressions
</success_criteria>

<output>
After completion, create `.planning/phases/02-tui-integration/02-02-SUMMARY.md`
</output>
